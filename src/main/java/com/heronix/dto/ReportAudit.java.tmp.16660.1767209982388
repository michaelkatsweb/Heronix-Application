package com.heronix.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Report Audit DTO
 *
 * Represents audit trail and compliance tracking for reports.
 *
 * Features:
 * - Comprehensive audit logging
 * - User activity tracking
 * - Data access monitoring
 * - Compliance rule management
 * - Regulatory reporting
 * - Retention policies
 * - Security events
 * - Privacy tracking (GDPR, CCPA, etc.)
 *
 * Audit Types:
 * - ACCESS - Report access events
 * - MODIFICATION - Report modification events
 * - CREATION - Report creation events
 * - DELETION - Report deletion events
 * - EXPORT - Report export events
 * - SHARE - Report sharing events
 * - PERMISSION - Permission changes
 * - SECURITY - Security-related events
 *
 * Compliance Standards:
 * - GDPR (General Data Protection Regulation)
 * - HIPAA (Health Insurance Portability and Accountability Act)
 * - SOX (Sarbanes-Oxley Act)
 * - PCI_DSS (Payment Card Industry Data Security Standard)
 * - FERPA (Family Educational Rights and Privacy Act)
 * - SOC2 (Service Organization Control 2)
 * - ISO27001 (Information Security Management)
 * - CUSTOM (Custom compliance requirements)
 *
 * @author Heronix Development Team
 * @version 1.0
 * @since Phase 86 - Report Audit & Compliance
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReportAudit {

    private Long auditId;
    private Long reportId;
    private String reportName;
    private String reportType;

    // Audit configuration
    private Boolean auditEnabled;
    private AuditLevel auditLevel;
    private Boolean trackAccess;
    private Boolean trackModifications;
    private Boolean trackExports;
    private Boolean trackSharing;
    private Boolean trackPermissions;
    private Boolean trackSecurityEvents;

    // Compliance configuration
    private List<ComplianceStandard> complianceStandards;
    private Boolean complianceEnabled;
    private Boolean autoReportingEnabled;
    private Integer reportingIntervalDays;
    private LocalDateTime lastComplianceReportAt;
    private LocalDateTime nextComplianceReportAt;

    // Retention policy
    private Boolean retentionEnabled;
    private Integer retentionPeriodDays;
    private RetentionAction retentionAction;
    private Boolean archiveEnabled;
    private String archiveLocation;

    // Audit trail
    private List<AuditEntry> auditTrail;
    private Long totalEvents;
    private Long accessEvents;
    private Long modificationEvents;
    private Long exportEvents;
    private Long securityEvents;

    // User activity
    private List<UserActivity> userActivities;
    private Map<String, Long> activityByUser;
    private Map<String, Long> activityByAction;

    // Data access tracking
    private List<DataAccess> dataAccessLog;
    private Long totalAccesses;
    private Long uniqueUsers;
    private Map<String, Long> accessByDataField;

    // Compliance status
    private ComplianceStatus overallComplianceStatus;
    private List<ComplianceRule> complianceRules;
    private List<ComplianceViolation> violations;
    private Integer totalViolations;
    private Integer criticalViolations;
    private Integer resolvedViolations;

    // Security tracking
    private List<SecurityEvent> securityEvents;
    private Integer failedAccessAttempts;
    private Integer unauthorizedAccessAttempts;
    private LocalDateTime lastSecurityIncident;

    // Privacy tracking
    private Boolean privacyTrackingEnabled;
    private List<PrivacyEvent> privacyEvents;
    private Map<String, Integer> piiAccessCount;
    private Boolean consentRequired;
    private List<ConsentRecord> consentRecords;

    // Metadata
    private LocalDateTime createdAt;
    private String createdBy;
    private LocalDateTime lastAuditAt;
    private String lastAuditBy;

    /**
     * Audit Level
     */
    public enum AuditLevel {
        MINIMAL,      // Basic audit logging
        STANDARD,     // Standard audit logging
        DETAILED,     // Detailed audit logging
        COMPREHENSIVE // Complete audit logging with full details
    }

    /**
     * Audit Type
     */
    public enum AuditType {
        ACCESS,       // Report access
        MODIFICATION, // Report modification
        CREATION,     // Report creation
        DELETION,     // Report deletion
        EXPORT,       // Report export
        SHARE,        // Report sharing
        PERMISSION,   // Permission change
        SECURITY,     // Security event
        COMPLIANCE,   // Compliance event
        PRIVACY       // Privacy event
    }

    /**
     * Compliance Standard
     */
    public enum ComplianceStandard {
        GDPR,       // General Data Protection Regulation
        HIPAA,      // Health Insurance Portability and Accountability Act
        SOX,        // Sarbanes-Oxley Act
        PCI_DSS,    // Payment Card Industry Data Security Standard
        FERPA,      // Family Educational Rights and Privacy Act
        SOC2,       // Service Organization Control 2
        ISO27001,   // Information Security Management
        CUSTOM      // Custom compliance requirements
    }

    /**
     * Compliance Status
     */
    public enum ComplianceStatus {
        COMPLIANT,        // Fully compliant
        NON_COMPLIANT,    // Not compliant
        PARTIALLY_COMPLIANT, // Partially compliant
        UNDER_REVIEW,     // Under compliance review
        REMEDIATION       // In remediation process
    }

    /**
     * Retention Action
     */
    public enum RetentionAction {
        DELETE,    // Delete after retention period
        ARCHIVE,   // Archive after retention period
        ALERT,     // Alert when retention period expires
        NONE       // No action
    }

    /**
     * Action Type
     */
    public enum ActionType {
        VIEW, CREATE, UPDATE, DELETE, EXPORT, SHARE, DOWNLOAD,
        PRINT, SCHEDULE, EXECUTE, APPROVE, REJECT, ARCHIVE,
        RESTORE, PURGE, ENCRYPT, DECRYPT, GRANT_ACCESS, REVOKE_ACCESS
    }

    /**
     * Audit Entry
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AuditEntry {
        private String entryId;
        private AuditType auditType;
        private ActionType action;
        private String userId;
        private String username;
        private String ipAddress;
        private String userAgent;
        private LocalDateTime timestamp;
        private String description;
        private Map<String, Object> details;
        private String resourceId;
        private String resourceType;
        private String beforeState;
        private String afterState;
        private Boolean success;
        private String errorMessage;
        private Long durationMs;
    }

    /**
     * User Activity
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UserActivity {
        private String userId;
        private String username;
        private String email;
        private LocalDateTime firstAccess;
        private LocalDateTime lastAccess;
        private Long totalAccesses;
        private Long totalModifications;
        private Long totalExports;
        private Map<ActionType, Long> actionCounts;
        private List<String> ipAddresses;
        private Boolean suspicious;
        private String suspiciousReason;
    }

    /**
     * Data Access
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DataAccess {
        private String accessId;
        private String userId;
        private String username;
        private LocalDateTime accessTime;
        private String dataField;
        private String dataValue;
        private Boolean isPII;
        private Boolean isSensitive;
        private String accessReason;
        private Boolean consentGiven;
        private String consentId;
        private String accessMethod;
    }

    /**
     * Compliance Rule
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ComplianceRule {
        private String ruleId;
        private String ruleName;
        private String description;
        private ComplianceStandard standard;
        private String ruleType;
        private Boolean enabled;
        private Boolean automated;
        private String condition;
        private String expectedValue;
        private String actualValue;
        private ComplianceStatus status;
        private LocalDateTime lastChecked;
        private LocalDateTime nextCheck;
        private Integer violationCount;
        private String remediationAction;
    }

    /**
     * Compliance Violation
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ComplianceViolation {
        private String violationId;
        private String ruleId;
        private String ruleName;
        private ComplianceStandard standard;
        private String severity;
        private String description;
        private LocalDateTime detectedAt;
        private String detectedBy;
        private Boolean resolved;
        private LocalDateTime resolvedAt;
        private String resolvedBy;
        private String resolution;
        private Map<String, Object> evidence;
        private String impact;
        private String recommendation;
    }

    /**
     * Security Event
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class SecurityEvent {
        private String eventId;
        private String eventType;
        private String severity;
        private String userId;
        private String ipAddress;
        private LocalDateTime timestamp;
        private String description;
        private Boolean blocked;
        private String blockReason;
        private Map<String, Object> details;
        private Boolean investigated;
        private String investigation;
    }

    /**
     * Privacy Event
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PrivacyEvent {
        private String eventId;
        private String eventType;
        private String userId;
        private String dataSubject;
        private LocalDateTime timestamp;
        private String piiField;
        private String purpose;
        private Boolean consentGiven;
        private String legalBasis;
        private Boolean notificationSent;
        private String processingActivity;
    }

    /**
     * Consent Record
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ConsentRecord {
        private String consentId;
        private String userId;
        private String dataSubject;
        private String purpose;
        private Boolean consentGiven;
        private LocalDateTime consentDate;
        private LocalDateTime expiryDate;
        private Boolean withdrawn;
        private LocalDateTime withdrawnDate;
        private String consentMethod;
        private String evidenceLocation;
    }

    /**
     * Helper Methods
     */

    public void logAudit(AuditEntry entry) {
        if (auditTrail == null) {
            auditTrail = new ArrayList<>();
        }
        auditTrail.add(entry);
        totalEvents = (totalEvents != null ? totalEvents : 0L) + 1;

        switch (entry.getAuditType()) {
            case ACCESS -> accessEvents = (accessEvents != null ? accessEvents : 0L) + 1;
            case MODIFICATION -> modificationEvents = (modificationEvents != null ? modificationEvents : 0L) + 1;
            case EXPORT -> exportEvents = (exportEvents != null ? exportEvents : 0L) + 1;
            case SECURITY -> securityEvents = (securityEvents != null ? securityEvents : 0L) + 1;
        }

        lastAuditAt = LocalDateTime.now();
    }

    public void addUserActivity(UserActivity activity) {
        if (userActivities == null) {
            userActivities = new ArrayList<>();
        }
        userActivities.add(activity);

        if (activityByUser == null) {
            activityByUser = new HashMap<>();
        }
        activityByUser.put(activity.getUserId(),
                (activityByUser.getOrDefault(activity.getUserId(), 0L)) + 1);
    }

    public void logDataAccess(DataAccess access) {
        if (dataAccessLog == null) {
            dataAccessLog = new ArrayList<>();
        }
        dataAccessLog.add(access);
        totalAccesses = (totalAccesses != null ? totalAccesses : 0L) + 1;

        if (accessByDataField == null) {
            accessByDataField = new HashMap<>();
        }
        accessByDataField.put(access.getDataField(),
                accessByDataField.getOrDefault(access.getDataField(), 0L) + 1);
    }

    public void addComplianceRule(ComplianceRule rule) {
        if (complianceRules == null) {
            complianceRules = new ArrayList<>();
        }
        complianceRules.add(rule);
    }

    public void recordViolation(ComplianceViolation violation) {
        if (violations == null) {
            violations = new ArrayList<>();
        }
        violations.add(violation);
        totalViolations = (totalViolations != null ? totalViolations : 0) + 1;

        if ("CRITICAL".equalsIgnoreCase(violation.getSeverity())) {
            criticalViolations = (criticalViolations != null ? criticalViolations : 0) + 1;
        }

        updateComplianceStatus();
    }

    public void resolveViolation(String violationId, String resolvedBy, String resolution) {
        if (violations != null) {
            for (ComplianceViolation violation : violations) {
                if (violation.getViolationId().equals(violationId) && !Boolean.TRUE.equals(violation.getResolved())) {
                    violation.setResolved(true);
                    violation.setResolvedAt(LocalDateTime.now());
                    violation.setResolvedBy(resolvedBy);
                    violation.setResolution(resolution);
                    resolvedViolations = (resolvedViolations != null ? resolvedViolations : 0) + 1;
                    updateComplianceStatus();
                    break;
                }
            }
        }
    }

    public void logSecurityEvent(SecurityEvent event) {
        if (securityEvents == null) {
            securityEvents = new ArrayList<>();
        }
        securityEvents.add(event);

        if ("FAILED_ACCESS".equals(event.getEventType())) {
            failedAccessAttempts = (failedAccessAttempts != null ? failedAccessAttempts : 0) + 1;
        } else if ("UNAUTHORIZED_ACCESS".equals(event.getEventType())) {
            unauthorizedAccessAttempts = (unauthorizedAccessAttempts != null ? unauthorizedAccessAttempts : 0) + 1;
        }

        lastSecurityIncident = LocalDateTime.now();
    }

    public void logPrivacyEvent(PrivacyEvent event) {
        if (privacyEvents == null) {
            privacyEvents = new ArrayList<>();
        }
        privacyEvents.add(event);

        if (event.getPiiField() != null) {
            if (piiAccessCount == null) {
                piiAccessCount = new HashMap<>();
            }
            piiAccessCount.put(event.getPiiField(),
                    piiAccessCount.getOrDefault(event.getPiiField(), 0) + 1);
        }
    }

    public void recordConsent(ConsentRecord consent) {
        if (consentRecords == null) {
            consentRecords = new ArrayList<>();
        }
        consentRecords.add(consent);
    }

    public void updateComplianceStatus() {
        if (violations == null || violations.isEmpty()) {
            overallComplianceStatus = ComplianceStatus.COMPLIANT;
            return;
        }

        long unresolvedViolations = violations.stream()
                .filter(v -> !Boolean.TRUE.equals(v.getResolved()))
                .count();

        long criticalUnresolved = violations.stream()
                .filter(v -> !Boolean.TRUE.equals(v.getResolved()) && "CRITICAL".equalsIgnoreCase(v.getSeverity()))
                .count();

        if (criticalUnresolved > 0) {
            overallComplianceStatus = ComplianceStatus.NON_COMPLIANT;
        } else if (unresolvedViolations > 0) {
            overallComplianceStatus = ComplianceStatus.PARTIALLY_COMPLIANT;
        } else {
            overallComplianceStatus = ComplianceStatus.COMPLIANT;
        }
    }

    public void calculateUniqueUsers() {
        if (userActivities != null) {
            uniqueUsers = (long) userActivities.stream()
                    .map(UserActivity::getUserId)
                    .distinct()
                    .count();
        }
    }

    public void checkRetentionPolicy() {
        if (!Boolean.TRUE.equals(retentionEnabled) || retentionPeriodDays == null) {
            return;
        }

        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(retentionPeriodDays);

        if (auditTrail != null) {
            auditTrail.removeIf(entry -> entry.getTimestamp().isBefore(cutoffDate));
        }
    }

    public void scheduleNextComplianceReport() {
        if (reportingIntervalDays != null) {
            nextComplianceReportAt = LocalDateTime.now().plusDays(reportingIntervalDays);
        }
    }

    public ComplianceRule getComplianceRule(String ruleId) {
        if (complianceRules != null) {
            return complianceRules.stream()
                    .filter(rule -> rule.getRuleId().equals(ruleId))
                    .findFirst()
                    .orElse(null);
        }
        return null;
    }

    public UserActivity getUserActivity(String userId) {
        if (userActivities != null) {
            return userActivities.stream()
                    .filter(activity -> activity.getUserId().equals(userId))
                    .findFirst()
                    .orElse(null);
        }
        return null;
    }

    public List<ComplianceViolation> getUnresolvedViolations() {
        if (violations == null) {
            return new ArrayList<>();
        }
        return violations.stream()
                .filter(v -> !Boolean.TRUE.equals(v.getResolved()))
                .toList();
    }

    public List<ComplianceViolation> getCriticalViolations() {
        if (violations == null) {
            return new ArrayList<>();
        }
        return violations.stream()
                .filter(v -> "CRITICAL".equalsIgnoreCase(v.getSeverity()))
                .toList();
    }

    public boolean isCompliant() {
        return overallComplianceStatus == ComplianceStatus.COMPLIANT;
    }

    public boolean needsComplianceReport() {
        if (!Boolean.TRUE.equals(autoReportingEnabled)) {
            return false;
        }
        return nextComplianceReportAt != null && LocalDateTime.now().isAfter(nextComplianceReportAt);
    }
}
